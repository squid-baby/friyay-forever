/*
 * =====================================================
 * FRIYAY FOREVER - Protocol 1.0 (v24 - BACK TO BASICS)
 * For ESP32-8048S043C (4.3" 800x480 RGB Display)
 * =====================================================
 * 
 * Going back to TAMC_GT911 library with pin 18 for INT
 * Adding extensive debug output to diagnose issues
 */

 #include <Arduino.h>
 #include <Arduino_GFX_Library.h>
 #include <WiFi.h>
 #include <WebServer.h>
 #include <DNSServer.h>
 #include <HTTPClient.h>
 #include <ArduinoJson.h>
 #include <WiFiClientSecure.h>
 #include <UniversalTelegramBot.h>
 #include <time.h>
 #include <Wire.h>
 #include <Preferences.h>
 #include <TAMC_GT911.h>
 
 // ============================================================
 // CONFIGURATION - CHANGE THESE FOR EACH UNIT
 // ============================================================
 
 #define MY_FRIEND_INDEX 0  // 0=NM, 1=ST, 2=GO, 3=TD, 4=MD
 
 #define BOT_TOKEN "8274851974:AAEao868jidxcQEnY8IxPK91ujLmOsA_Alg"
 
 struct Friend {
   const char* initials;
  const char* firstName;
   int64_t telegramId;
   bool committed;
 };
 
 Friend friends[] = {
   {"NM", "Nathan", 7612996805LL, false},
   {"ST", "Simon", 7015581601LL, false},
   {"GO", "Grahame", 0LL, false},
   {"TD", "Tony", 8293810017LL, false},
   {"MD", "Matt", 0LL, false}
 };
 #define NUM_FRIENDS 5
 
 #define LATITUDE 35.9132
 #define LONGITUDE -79.0558
 
 // ============================================================
 // PIN DEFINITIONS - ESP32-8048S043C (from working README)
 // ============================================================
 #define GFX_BL 2
 #define MQ135_PIN 12
 
 // GT911 Touch - Using pins from README
 #define TOUCH_SDA 19
 #define TOUCH_SCL 20
 #define TOUCH_INT 18
 #define TOUCH_RST 38
 
 // ============================================================
 // DISPLAY SETUP - ESP32-8048S043C
 // ============================================================
 Arduino_ESP32RGBPanel *rgbpanel = new Arduino_ESP32RGBPanel(
     40 /* DE */, 41 /* VSYNC */, 39 /* HSYNC */, 42 /* PCLK */,
     45 /* R0 */, 48 /* R1 */, 47 /* R2 */, 21 /* R3 */, 14 /* R4 */,
     5 /* G0 */, 6 /* G1 */, 7 /* G2 */, 15 /* G3 */, 16 /* G4 */, 4 /* G5 */,
     8 /* B0 */, 3 /* B1 */, 46 /* B2 */, 9 /* B3 */, 1 /* B4 */,
     0 /* hsync_polarity */, 8 /* hsync_front_porch */, 4 /* hsync_pulse_width */, 8 /* hsync_back_porch */,
     0 /* vsync_polarity */, 8 /* vsync_front_porch */, 4 /* vsync_pulse_width */, 8 /* vsync_back_porch */,
     1 /* pclk_active_neg */, 16000000 /* prefer_speed */
 );
 
 Arduino_RGB_Display *gfx = new Arduino_RGB_Display(800, 480, rgbpanel);
 
 // ============================================================
 // GT911 TOUCH - USING TAMC_GT911 LIBRARY
 // ============================================================
 TAMC_GT911 ts = TAMC_GT911(TOUCH_SDA, TOUCH_SCL, TOUCH_INT, TOUCH_RST, 800, 480);
 
 // ============================================================
 // COLORS (RGB565)
 // ============================================================
 #define COL_BLACK       0x0000
 #define COL_WHITE       0xFFFF
 #define COL_YELLOW      0xFEA0
 #define COL_CYAN        0x07FF
 #define COL_GREEN       0x3CA4
 #define COL_VU_GREEN    0x07E0
 #define COL_RED         0xF800
 #define COL_ORANGE      0xFC40
 #define COL_GRAY        0x52AA
 #define COL_DARK_GRAY   0x31A6
 #define COL_SPOTIFY_BG  0x1807
 #define COL_SCANNER     0x055F
 
 // ============================================================
 // LAYOUT (800x480)
 // ============================================================
 #define SCREEN_W 800
 #define SCREEN_H 480
 #define MARGIN 15
 
 #define NOTIF_W 270
 #define NOTIF_H 50
 #define NOTIF_X (SCREEN_W - NOTIF_W - MARGIN)
 #define NOTIF_Y MARGIN
 
 #define BTN_Y 10
 #define BTN_H 50
 #define BTN_W 60
 #define BTN_GAP 6
 #define COMMIT_W 80
 
 #define BOTTOM_LINE (SCREEN_H - MARGIN)
 
 #define ALBUM_ART_W 225
 #define ALBUM_ART_H 280
 #define SPOT_HEADER_H 45
 #define SPOT_TOTAL_H (SPOT_HEADER_H + ALBUM_ART_H)
 #define SPOT_BOTTOM BOTTOM_LINE
 #define SPOT_TOP (SPOT_BOTTOM - SPOT_TOTAL_H)
 #define ART_X (SCREEN_W - ALBUM_ART_W - MARGIN)
 #define ART_AREA_Y (SPOT_TOP + SPOT_HEADER_H)
 
 #define VU_W 38
 #define VU_GAP 10
 #define VU_TOTAL_W (VU_W * 2 + VU_GAP)
 #define ELEMENT_GAP 15
 #define VU_X (ART_X - ELEMENT_GAP - VU_TOTAL_W)
 #define VU_TOP SPOT_TOP
 #define VU_BOTTOM BOTTOM_LINE
 #define VU_H (VU_BOTTOM - VU_TOP)
 
 #define TIMER_H 140
 #define TIMER_BOTTOM BOTTOM_LINE
 #define TIMER_Y (TIMER_BOTTOM - TIMER_H)
 #define TIMER_X MARGIN
 #define TIMER_W (VU_X - ELEMENT_GAP - MARGIN)
 
 #define PANEL_X MARGIN
 #define PANEL_TOP SPOT_TOP
 #define PANEL_BOTTOM (TIMER_Y - 8)
 #define PANEL_H (PANEL_BOTTOM - PANEL_TOP)
 #define PANEL_W TIMER_W
 #define PANEL_Y PANEL_TOP
 
 #define DAY_H 28
 #define DAYS_Y (PANEL_TOP - 5 - DAY_H)
 
 #define HEADER_Y (DAYS_Y + DAY_H / 2)
 
 #define WEATHER_START_Y (PANEL_Y + 15)
 #define WEATHER_ROW_GAP ((PANEL_H - 25) / 3)
 #define BLOCK_SIZE 28
 #define BLOCK_GAP 4
 
 // ============================================================
 // GLOBAL STATE
 // ============================================================
 
 Preferences prefs;
 String savedSSID = "";
 String savedPass = "";
 bool wifiOK = false;
 bool inSetup = false;
 
 WebServer server(80);
 DNSServer dns;
 bool kbVisible = false;
 String kbInput = "";
 bool capsOn = false;
 int selNetwork = -1;
 String networks[15];
 int netCount = 0;
 
 float currTemp = 70;
 float precipitation = 0;
 int wetLvl = 5;
 int tmpLvl = 5;
 int fukLvl = 5;
 bool weatherOK = false;
 
 int aqiLvl = 5;
 int co2Lvl = 5;
 
 struct tm tinfo;
 int dayOfWeek = 0;
 long secToFri = 0;
 int hrsLeft = 0;
 int minLeft = 0;
 int secLeft = 0;
 
 String currMsg = "";
 bool newMsg = false;
 unsigned long msgTime = 0;
 bool showingMsg = false;
 int msgScrollPos = 0;
 
 bool scannerActive = false;
 int scannerPos = 4;
 int scannerDirection = 1;
 int scannerBounces = 0;
unsigned long scannerStartTime = 0;
 #define SCANNER_DURATION 30000
 #define SCANNER_SPEED 8
 
 bool hasSpotify = false;
 String trackId = "";
 
 // Touch variables
 int touchX = 0, touchY = 0;
 unsigned long lastTouch = 0;
 bool touchOK = false;
 

// Touch state machine for proper press/release detection
enum TouchState { TOUCH_IDLE, TOUCH_PRESSED, TOUCH_HELD };
TouchState touchState = TOUCH_IDLE;
bool wasTouched = false;
int savedTouchX = 0, savedTouchY = 0;
 int wifiStrength = 4;
 bool profileActive = true;
 
 unsigned long lastWeather = 0;
 unsigned long lastBot = 0;
 unsigned long lastDisp = 0;
 unsigned long lastSensor = 0;
 unsigned long lastAnim = 0;
 
 WiFiClientSecure client;
 UniversalTelegramBot bot(BOT_TOKEN, client);
 
 // ============================================================
 // FUNCTION PROTOTYPES
 // ============================================================
 void showSplash();
 void initTouch();
 bool checkTouch();
 void handleTouch();
 void handleSetupTouch();
 void handleKBTouch();
 void toggleCommit();
 void drawUI();
 void drawButtons();
 void drawNotificationBox();
 void drawDays();
 void drawWeatherPanel();
 void drawWeatherBars();
 void drawTimer();
 void drawVUMeters();
 void drawMeter(int x, int y, int w, int h, int level, const char* label);
 void drawHeader();
 void drawWifiIcon(int x, int y);
 void drawProfileIcon(int x, int y);
 void drawSpotifyArea();
 void startWiFiSetup();
 void drawNetList();
 void drawKeyboard();
 void doConnect();
 void tryConnect();
 void handleRoot();
 void checkTelegram();
 void showMessage(String msg);
 int getFriendIdx(int64_t id);
 void broadcast(String msg);
 void parseSpotify(String text);
 void getWeather();
 void calcWeather();
 void readSensors();
 void calcCountdown();
 void checkReset();
 void updateAnimations();
 void drawTouchDebug();
 
 // ============================================================
 // TOUCH INITIALIZATION
 // ============================================================
 
 void initTouch() {
   Serial.println("   Starting GT911 init...");
   
   Wire.begin(TOUCH_SDA, TOUCH_SCL);
   Serial.println("   Wire.begin() done");
   
   ts.begin();
   Serial.println("   ts.begin() done");
   
   ts.setRotation(ROTATION_NORMAL);
   Serial.println("   ts.setRotation() done");
   
   touchOK = true;
   Serial.println("   GT911 initialized!");
}

// ============================================================
// TOUCH READING
// ============================================================

bool checkTouch() {
  if (!touchOK) return false;

  ts.read();
  bool currentlyTouched = ts.isTouched;

  // State machine for proper press/release detection
  switch (touchState) {
    case TOUCH_IDLE:
      if (currentlyTouched && !wasTouched) {
        // Finger just touched - save coordinates
        int rawX = ts.points[0].x;
        int rawY = ts.points[0].y;

        // CALIBRATED MAPPING
        savedTouchX = map(rawX, 792, 325, 0, 800);
        savedTouchY = map(rawY, 471, 209, 0, 480);
        savedTouchX = constrain(savedTouchX, 0, SCREEN_W - 1);
        savedTouchY = constrain(savedTouchY, 0, SCREEN_H - 1);

        touchState = TOUCH_PRESSED;
        wasTouched = true;

        Serial.printf("Touch PRESS: x=%d, y=%d\n", savedTouchX, savedTouchY);
      }
      break;

    case TOUCH_PRESSED:
      if (!currentlyTouched) {
        // Finger released - trigger action NOW
        touchX = savedTouchX;
        touchY = savedTouchY;
        touchState = TOUCH_IDLE;
        wasTouched = false;

        Serial.printf("Touch RELEASE: x=%d, y=%d\n", touchX, touchY);
        return true;
      }
      break;

    case TOUCH_HELD:
      if (!currentlyTouched) {
        touchState = TOUCH_IDLE;
        wasTouched = false;
      }
      break;
  }

  return false;
}
 
 // ============================================================
 // TOUCH DEBUG
 // ============================================================
 
 void drawTouchDebug() {
   gfx->fillCircle(touchX, touchY, 10, COL_RED);
 }
 
 // ============================================================
 // SETUP
 // ============================================================
 
 void setup() {
   Serial.begin(115200);
   delay(500);  // Give serial time to initialize
   
   Serial.println();
   Serial.println("========================================");
   Serial.println("  FRIYAY FOREVER Protocol 1.0 - v24");
   Serial.println("  BACK TO BASICS - DEBUG VERSION");
   Serial.println("========================================");
   Serial.printf("Unit owner: %s\n\n", friends[MY_FRIEND_INDEX].initials);
 
   Serial.println("[1/5] Init display...");
   gfx->begin();
   gfx->fillScreen(COL_BLACK);
   pinMode(GFX_BL, OUTPUT);
   digitalWrite(GFX_BL, HIGH);
   Serial.println("   Display OK");
   
   showSplash();
   
   Serial.println("[2/5] Init touch...");
   initTouch();
   
   Serial.println("[3/5] Init sensor...");
   pinMode(MQ135_PIN, INPUT);
   analogReadResolution(12);
   Serial.println("   Sensor OK");
   
   Serial.println("[4/5] Check WiFi...");
   prefs.begin("friyay", false);
   savedSSID = prefs.getString("ssid", "");
   savedPass = prefs.getString("pass", "");
   Serial.printf("   Saved SSID: %s\n", savedSSID.c_str());
   
   if (savedSSID.length() > 0) {
     tryConnect();
   }
   
   if (!wifiOK) {
     Serial.println("   Starting WiFi setup...");
     startWiFiSetup();
     return;
   }
   
   Serial.println("[5/5] Sync time...");
   configTime(-5 * 3600, 3600, "pool.ntp.org");
   
   int tries = 0;
   while (!getLocalTime(&tinfo) && tries < 15) {
     delay(500);
     tries++;
   }
   Serial.println("   Time synced");
   
   client.setInsecure();
   getWeather();
   
   int rssi = WiFi.RSSI();
   if (rssi >= -50) wifiStrength = 4;
   else if (rssi >= -60) wifiStrength = 3;
   else if (rssi >= -70) wifiStrength = 2;
   else wifiStrength = 1;
   
   drawUI();
   
   Serial.println();
   Serial.println("========================================");
   Serial.println("  READY! Touch the screen to test.");
   Serial.println("========================================");
   Serial.println();
 }
 
 // ============================================================
 // MAIN LOOP
 // ============================================================
 
 void loop() {
   if (inSetup) {
     dns.processNextRequest();
     server.handleClient();
     if (checkTouch()) {
       drawTouchDebug();
       handleSetupTouch();
     }
     delay(10);
     return;
   }
   
   unsigned long now = millis();
   
   if (now - lastAnim >= 16) {
     lastAnim = now;
     updateAnimations();
   }
   
   if (now - lastDisp >= 1000) {
     lastDisp = now;
     getLocalTime(&tinfo);
     dayOfWeek = tinfo.tm_wday;
     calcCountdown();
     drawTimer();
     
     if (WiFi.status() == WL_CONNECTED) {
       int rssi = WiFi.RSSI();
       int newStrength = rssi >= -50 ? 4 : rssi >= -60 ? 3 : rssi >= -70 ? 2 : 1;
       if (newStrength != wifiStrength) {
         wifiStrength = newStrength;
         drawHeader();
       }
     }
     
     checkReset();
   }
   
   if (checkTouch()) {
     drawTouchDebug();
     handleTouch();
   }
   
   if (now - lastBot >= 2000) {
     lastBot = now;
     checkTelegram();
   }
   
   if (now - lastWeather >= 3600000) {
     lastWeather = now;
     getWeather();
     drawWeatherBars();
   }
   
   if (now - lastSensor >= 5000) {
     lastSensor = now;
     readSensors();
     drawVUMeters();
   }
   
   if (WiFi.status() != WL_CONNECTED) {
     wifiOK = false;
     tryConnect();
     if (!wifiOK) startWiFiSetup();
   }
   
   delay(10);
 }
 
 // ============================================================
 // ANIMATION UPDATE
 // ============================================================
 
 void updateAnimations() {
   bool needRedraw = false;
   
   if (scannerActive) {
    // Check if 30 seconds elapsed
    if (millis() - scannerStartTime >= SCANNER_DURATION) {
      scannerActive = false;
      scannerPos = 4;
      scannerDirection = 1;
      needRedraw = true;
    } else {
      scannerPos += SCANNER_SPEED * scannerDirection;

      if (scannerDirection == 1 && scannerPos >= NOTIF_W - 10) {
        scannerDirection = -1;
        scannerPos = NOTIF_W - 10;
      } else if (scannerDirection == -1 && scannerPos <= 4) {
        scannerDirection = 1;
        scannerPos = 4;
      }

      needRedraw = true;
    }
     needRedraw = true;
   }
   
   if (showingMsg && currMsg.length() > 20) {
     msgScrollPos += 2;
     if (msgScrollPos > (int)currMsg.length() * 18 + TIMER_W) {
       msgScrollPos = -TIMER_W;
     }
     needRedraw = true;
   }
   
   if (needRedraw) {
     drawNotificationBox();
     if (showingMsg) drawTimer();
   }
 }
 
 // ============================================================
 // TOUCH HANDLERS
 // ============================================================
 
 void handleTouch() {
   if (touchY >= BTN_Y && touchY <= BTN_Y + BTN_H) {
     int x = MARGIN;
     for (int i = 0; i < NUM_FRIENDS; i++) {
       if (touchX >= x && touchX <= x + BTN_W) {
         if (i == MY_FRIEND_INDEX) {
           toggleCommit();
         }
         return;
       }
       x += BTN_W + BTN_GAP;
     }
     
     x += 10;
     if (touchX >= x && touchX <= x + COMMIT_W) {
       toggleCommit();
       return;
     }
   }
 }
 
 void toggleCommit() {
   friends[MY_FRIEND_INDEX].committed = !friends[MY_FRIEND_INDEX].committed;

  String displayMsg = friends[MY_FRIEND_INDEX].committed
    ? String(friends[MY_FRIEND_INDEX].firstName) + " is IN"
    : String(friends[MY_FRIEND_INDEX].firstName) + " is OUT";

  showMessage(displayMsg);
   
   String msg = friends[MY_FRIEND_INDEX].committed 
     ? "ðŸ‚ " + String(friends[MY_FRIEND_INDEX].initials) + " is IN!"
     : "ðŸ˜¢ " + String(friends[MY_FRIEND_INDEX].initials) + " is OUT";
   
   broadcast(msg);
   drawButtons();
   
   Serial.printf("Commit toggled: %s\n", friends[MY_FRIEND_INDEX].committed ? "IN" : "OUT");
 }
 
 // ============================================================
 // DRAWING FUNCTIONS
 // ============================================================
 
 void showSplash() {
   gfx->fillScreen(COL_BLACK);
   gfx->setTextColor(COL_YELLOW);
   gfx->setTextSize(4);
   gfx->setCursor(160, 180);
   gfx->print("FRIYAY FOREVER");
   gfx->setTextSize(2);
   gfx->setTextColor(COL_CYAN);
   gfx->setCursor(290, 250);
   gfx->print("Protocol 1.0 v24");
   gfx->setTextColor(COL_WHITE);
   gfx->setCursor(320, 300);
   gfx->print("Unit: ");
   gfx->print(friends[MY_FRIEND_INDEX].initials);
   delay(2000);
 }
 
 void drawUI() {
   gfx->fillScreen(COL_BLACK);
   drawButtons();
   drawNotificationBox();
   drawDays();
   drawWeatherPanel();
   drawWeatherBars();
   drawTimer();
   drawVUMeters();
   drawHeader();
   drawSpotifyArea();
 }
 
 void drawButtons() {
   int x = MARGIN;
   
   for (int i = 0; i < NUM_FRIENDS; i++) {
     if (friends[i].committed) {
       gfx->fillRoundRect(x, BTN_Y, BTN_W, BTN_H, 6, COL_YELLOW);
       gfx->setTextColor(COL_BLACK);
     } else {
       gfx->fillRoundRect(x, BTN_Y, BTN_W, BTN_H, 6, COL_BLACK);
       gfx->drawRoundRect(x, BTN_Y, BTN_W, BTN_H, 6, COL_YELLOW);
       gfx->setTextColor(COL_YELLOW);
     }
     
     gfx->setTextSize(2);
     int tw = strlen(friends[i].initials) * 12;
     gfx->setCursor(x + (BTN_W - tw) / 2, BTN_Y + 17);
     gfx->print(friends[i].initials);
     
     x += BTN_W + BTN_GAP;
   }
   
   x += 10;
   gfx->fillRoundRect(x, BTN_Y, COMMIT_W, BTN_H, 6, COL_YELLOW);
   gfx->setTextColor(COL_BLACK);
   gfx->setTextSize(2);
   gfx->setCursor(x + 8, BTN_Y + 17);
   gfx->print("Commit");
 }
 
 void drawNotificationBox() {
   gfx->fillRect(NOTIF_X - 2, NOTIF_Y - 2, NOTIF_W + 4, NOTIF_H + 4, COL_BLACK);
   gfx->drawRoundRect(NOTIF_X, NOTIF_Y, NOTIF_W, NOTIF_H, 6, COL_CYAN);
   gfx->fillRect(NOTIF_X + 2, NOTIF_Y + 2, NOTIF_W - 4, NOTIF_H - 4, 0x0011);
   
   if (scannerActive) {
    // Check if 30 seconds elapsed
    if (millis() - scannerStartTime >= SCANNER_DURATION) {
      scannerActive = false;
      scannerPos = 4;
      scannerDirection = 1;
      needRedraw = true;
    } else {
      scannerPos += SCANNER_SPEED * scannerDirection;

      if (scannerDirection == 1 && scannerPos >= NOTIF_W - 10) {
        scannerDirection = -1;
        scannerPos = NOTIF_W - 10;
      } else if (scannerDirection == -1 && scannerPos <= 4) {
        scannerDirection = 1;
        scannerPos = 4;
      }

      needRedraw = true;
    }
